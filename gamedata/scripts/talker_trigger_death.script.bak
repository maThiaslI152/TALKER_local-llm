package.path = package.path .. ";./bin/lua/?.lua;"
local interface = require("interface.interface")
local game = require("infra.game_adapter")
local log = require('framework.logger')

--------------------------------------------------------------------------------------------
-- UTILS
--------------------------------------------------------------------------------------------

local function join_tables(table1, table2)
    local result = {}
    for _, value in ipairs(table1) do
        table.insert(result, value)
    end
    for _, value in ipairs(table2) do
        table.insert(result, value)
    end
    return result
end

--------------------------------------------------------------------------------------------
-- CALLBACK
--------------------------------------------------------------------------------------------

local queries = require("talker_game_queries")

local last_death_time_ms = 0
local death_cooldown_ms = 45 * 1000 -- 45 seconds global cooldown for random deaths
local companion_death_cooldown_ms = 2 * 1000 -- 2 seconds priority cooldown for companions (Rapid confirmation)

function on_creature_death(victim_obj, killer_obj)
    -- 1. Validity
    if not queries.is_living_character(killer_obj) then return end -- Only care if killer is alive (e.g. not anomaly)

    -- 2. Priority Logic
    local is_companion_kill = queries.is_companion(killer_obj)
    local time_diff = queries.get_game_time_ms() - last_death_time_ms
    
    -- Dynamically select threshold
    local required_cooldown = is_companion_kill and companion_death_cooldown_ms or death_cooldown_ms
    local timer_ok = time_diff > required_cooldown
    
    -- If timer is NOT ready, skip it
    if not timer_ok then
        return
    end
    
    -- Update timer (even for companion kills, reset the global timer to avoid immediate spam of non-companion confirmation?)
    -- Let's say yes, if HiP kills something, we don't need to hear about a random dog 1 second later.
    last_death_time_ms = queries.get_game_time_ms()

    local unformatted_description = "%s was killed by %s!"
    -- get and combine witnesses
    local witnesses_near_victim = game.get_characters_near(victim_obj)
    local witnesses_near_killer = game.get_characters_near(killer_obj)
    local witnesses = join_tables(witnesses_near_victim, witnesses_near_killer)
    -- make characters
    local killer = game.create_character(killer_obj)
    local victim = game.create_character(victim_obj)
    -- decide if the kill is important
    local important = true -- Important because we rely on the specific cooldowns (45s/5s) rather than a random chance
    -- send event to mod
    interface.register_game_event(unformatted_description, {victim, killer}, witnesses, important)
end

--------------------------------------------------------------------------------------------
-- Bubble Wrap
--------------------------------------------------------------------------------------------

local function safe_on_creature_death(victim_obj, killer_obj)
    local status, err = pcall(function()
        on_creature_death(victim_obj, killer_obj)
    end)
    if not status then
        log.error("Error in victim_on_death_callback: " .. err)
    end
end

--------------------------------------------------------------------------------------------
-- On Game Start
--------------------------------------------------------------------------------------------

function on_game_start()
    RegisterScriptCallback("npc_on_death_callback", safe_on_creature_death)
    RegisterScriptCallback("monster_on_death_callback", safe_on_creature_death)
end

function is_loaded()
    return true
end
---@diagnostic disable: undefined-global
package.path = package.path .. ";./bin/lua/?.lua;"
local interface = require("interface.interface")
local game = require("infra.game_adapter")
local log = require('framework.logger')

-- Import game interface modules
local queries = talker_game_queries
----------------------------------------------------------------------------------------------------
-- INFO
----------------------------------------------------------------------------------------------------
-- the callout trigger script is responsible for generating callouts from NPCs to other NPCs
-- on_enemy_eval occurs at high frequency, so we limit the amount of calls

-- RULES
-- on enemy eval
--      if the spotter is not in combat
--          call out the target

---------------------------------------------------------------------------------------------
-- CONDITIONS
--------------------------------------------------------------------------------------------

local last_callout_time_ms = 0
local callout_cooldown_ms = 45 * 1000 -- 45 seconds global
local companion_callout_cooldown_ms = 30 * 1000 -- 30 seconds for companions (Anti-spam)

function is_valid_callout(npc_obj, target_obj)
    -- 1. Basic Validity Checks
    if not queries.is_living_character(npc_obj) then return false end
    if not queries.is_alive(target_obj) then return false end -- Fix: Don't spot dead bodies
    
    -- Relation Check
    if not queries.are_enemies(npc_obj, target_obj) then return false end

    -- Companion Alignment: 
    -- If the spotter is a companion, ensure the target is ALSO an enemy of the player.
    -- This prevents companions from spotting "normal stalkers" (neutrals) that they might personally dislike due to faction logic.
    if is_companion and not queries.are_enemies(db.actor, target_obj) then
        return false
    end
    
    -- Safe Zone Heuristic:
    -- If a companion has their weapon strapped (holstered), they are likely in a safe zone or relaxed state.
    -- This avoids the stack overflow caused by calling xr_combat_ignore.is_enemy directly.
    if is_companion and not npc_obj:weapon_unstrapped() then
        return false
    end

    if queries.is_in_combat(npc_obj) then return false end

    -- 2. Timing Checks
    local is_companion = queries.is_companion(npc_obj)
    local current_time = time_global() -- Use direct engine time for reliable short-term cooldowns
    local time_diff = current_time - last_callout_time_ms
    
    -- Dynamic Threshold
    local required_cooldown = is_companion and companion_callout_cooldown_ms or callout_cooldown_ms
    local timer_ok = time_diff > required_cooldown
    
    -- Check
    if not timer_ok then
        return false
    end
    
    -- Reset timer ONLY if valid
    last_callout_time_ms = current_time
    return true
end

---------------------------------------------------------------------------------------------
-- ENEMY CALLOUTS
--------------------------------------------------------------------------------------------
function on_enemy_eval(npc_obj, target_obj)
    -- determine if it's a callout
    if not is_valid_callout(npc_obj, target_obj) then return end

    --- create callout event
    local unformatted_description = "%s spotted a %s"
    local spotter = game.create_character(npc_obj)
    local enemy = game.create_character(target_obj)
    local witnesses = {spotter} -- information is conveyed through their dialogue event itself

    -- register event
    log.info(spotter.name .. " spotted " .. enemy.name)
    interface.register_game_event(unformatted_description, {spotter, enemy}, witnesses, true)
end

--------------------------------------------------------------------------------------------
-- Set up
--------------------------------------------------------------------------------------------

local function safe_on_enemy_eval(observer_obj, target_obj)
    local status, err = pcall(function()
        on_enemy_eval(observer_obj, target_obj)
    end)
    if not status then
        log.error("Error in on_enemy_eval: " .. err)
    end
end

function on_game_start()
    RegisterScriptCallback("on_enemy_eval", safe_on_enemy_eval)
end

-- for validating all scripts have loaded
function is_loaded()
    return true
end